# 数据库



## 索引



[toc]



## 数据结构



### MySQL 中 varchar 和 char 的区别是什么？

1. 长度是否可变
   * char类型为定长, 长度固定, 如果插入长度效于定义长度, 则使用空格填充
   * varchar类型为变长, 长度可变, 存储数据按照实际长度存储, 插入多长就存多长
2. 存储的容量不同
   * char类型最多存放的字符个数为255, 与编码无关
   * varchar类型最多存放字符个数为65532, varchar类型的最大有效长度由最大行大小和使用的字符集确定, 整体最大长度为65532字节



* 参考资料
  
	* [varchar与char有什么区别](https://blog.csdn.net/qq_20264581/article/details/83755789)



## 锁机制



### 简述乐观锁以及悲观锁的区别以及使用场景



* 锁机制本身就是为了解决程序运行中产生的**并发问题**, 而乐观锁和悲观锁分别对应了两种策略

* 乐观锁

  * 每次事务需要读取对象时, 记录下当前的'版本号、时间戳等(称为x)'(应该就像git的commit), 只判断当前写入事务的x是否与读取时一致(比如github这种就提供在线记录x的功能), 如果一致则允许吸入, 否则拒绝.
  * 优点:
    * 因此, 这种锁更加适合高并发的多读少写的系统, (不要求持续占用单一线程, 但响应速度快)
  * 缺点:
    * 无法保证某两次数据写入操作之间是否发生了修改, ABA问题
  * 使用场景:
    * 版本控制系统: git、SVN

* 悲观锁

  * 当事务出现时, 悲观锁启动直到事务完成, 之后再处理下一个事务
  * 优点:
    * 保证了数据库操作的准确性
  * 缺点也很明显:
    1. 对于数据库的设计能力以及数据库功能间的独立性要求较高, 否则就会发生**死锁**
    2. 相当于'单线程'执行请求, 在高并发环境下会浪费大量资源
  * 使用场景:
    * 因为悲观锁一次只锁定一个事务, 所以变相缓解了并发, 但如果并发数据量极其庞大的时候, 这会造成资源的极大浪费, 所以适合并发量较小且用户能够接受高并发时运行效率低的项目.



* 参考资料
	* [Stackoverflow](https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking)

	* [海外兔是如何设计秒杀系统的](https://osjobs.net/system/posts/spike-system/)

	* [悲观锁和乐观锁的原理及使用场景](https://www.jianshu.com/p/232a86cbd4b0?utm_campaign)

	* [乐观锁与悲观锁各自适用场景是什么？](https://www.zhihu.com/question/29420056)



## 匹配



### 简述什么是最左匹配原则

* 概念
  * 数据库匹配的时候, 除了范围查询之外, 遵循最左优先的原则.

* 举例
  * 想要建立一个(a, b)的索引, 
    * 如果条件是(a=1 and b=2) √
    * 如果条件是(a=1) √
    * 如果条件是(b=2) ×



* 参考资料

	* [最左匹配原则](https://www.cnblogs.com/lanqi/p/10282279.html)

	* [Mysql联合索引最左匹配原则](https://segmentfault.com/a/1190000015416513)

	* [谈谈你对mysql联合索引的认识?](https://www.cnblogs.com/rjzheng/p/12557314.html)











## Redis

### 简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点

* 概念
  * RDB: 定期保存当前数据库的快照
  * AOF: 记录每次写入数据库的操作, 当数据库再次启动时执行, 重新构建数据集.
  * 混用: 当两种持久化模式同时开启时, 优先使用AOF文件进行数据构建, 因为相对来讲数据更完整
* RDB
  * 优点: 
    1. 将数据保存在单个文件中, 非常适宜备份数据在不同时段下的不同版本.
    2. 适用于灾难恢复, 单个文件很方便移动
    3. 相对于AOF模式来说, 恢复大数据集的速度更快
  * 缺点:
    1. 对数据的完整性不敏感, 如果要进行大规模数据恢复, 可能会丢失最后一次持久化后的数据
    2. 如果数据集过大且cpu性能不佳, 保存快照的过程可能会导致redis出现短暂的停止服务, 导致数据的丢失
* AOF
  * 优点:
    1. 相比于RDB, 持久化效果更好. 
    2. AOF表只能添加(append only), 即便是断电也不会出现数据准确性的问题
    3. Redis会在AOF文件过大的时候自动将其重写, 且在这个过程中不用担心数据的安全
  * 缺点;
    1. 对于同样的数据集, AOF文件一般比RDB文件大
    2. 取决于具体应用的刷新(fsync)策略, AOF可能会比RDB慢一些
    3. 可能会出现罕见的bug



* 参考资料
	[官方文档](https://redis.io/topics/persistence)
	[RDB和AOF](https://dunwu.github.io/db-tutorial/nosql/redis/redis-persistence.html#%E4%B8%89%E3%80%81rdb-%E5%92%8C-aof)
	[Redis持久化之RDB](https://blog.csdn.net/weixin_33892359/article/details/91944603)

