

* 从高频题中挑选出来, 作为着重理解的十道题



[toc]



## 网络

### 1. 简述常见的HTTP状态码的含义

* 1xx 提示信息
* 2xx 成功, 报文已经收到并被正确处理
* 3xx 重定向, 资源位置发生变动, 需要客户端重新发送请求
  * 301(Moved Permanently) 永久重定向, 请求的资源已经不存在, 需要使用新的URL再次访问 (包含Location字段, 指明后续的跳转URL, 浏览器会自动重定向)
  * 302(Found) 临时重定向, 请求的资源还在, 暂时需要用新的URL再次访问 (包含Location字段, 指明后续的跳转URL, 浏览器会自动重定向)
  * 304(Not Modified) 表示资源未修改, 重定向已存在的缓冲文件, 用于缓存控制(不具有跳转的含义)
* 4xx 客户端错误, 请求报文有误, 服务器无法处理
  * 400(Bad Request) 表示请求报文有误, 但属于笼统的错误
  * 403(Forbidden) 表示服务器禁止访问资源, 并非请求错误
  * 404(Not Found) 表示请求的资源在服务器上不存在或未找到, 所以无法提供给客户端.
* 5xx 服务器错误, 服务器在处理请求时内部发生了错误
  * 500(Internal Server Error) 笼统的通用错误码, 无法知晓服务器发生了什么错误(类似于400, 不过是在服务器端)
  * 501(Not Implemented) 表示客户端请求的功能尚不支持, 敬请期待
  * 502(Bad Gateway) 将服务器作为网关或代理时返回的错误码, 表示服务器自身工作正常, 访问后端服务器发生了错误
  * 503(Service Unavailable) 表示服务器当前很忙, 暂时无法相应服务器, 请稍后重试



* https://leetcode-cn.com/circle/discuss/cxn9hV/



### 2. HTTP和HTTPS的区别

* 基本

  1. 安全: 
     * HTTP是超文本传输协议, 信息是明文传输, 存在安全风险的问题. HTTPS解决了HTTP不安全的缺陷, 在TCP和HTTP网络层之间加入了SSL/TLS安全协议, 使得报文能够加密传输, 并且为了实现服务器身份可信, 需要向第三方CA(证书权威机构)申请数字证书.

  2. 连接建立

     * HTTP连接建立相对简单, TCP三次握手之后便可进行HTTP的报文传输. 而HTTPS在TCP三次握手之后, 还需进行SSL/TLS的握手过程, 才可进入加密报文传输.

  3. 端口号

		* HTTP的端口号是80, HTTPS的端口号是443

* 扩展
  1. HTTP存在的安全风险?
     * 窃听风险, 在通信链路上可以获取通信内容, 导致隐私泄露
     * 篡改风险, 强制植入垃圾广告, 影响用户使用体验
     * 冒充风险, 冒充在线支付网站(12306), 导致经济损失
     
  2. HTTPS有哪些改进?
     * HTTPS在HTTP和TCP层之间加入了SSL/TLS协议, 能够做到
     * 信息加密: 交互信息无法被窃取, 采用非对称加密(例外: 私钥泄露)
     * 校验机制: 无法篡改通信内容, 一旦发现数据被篡改就无法正常显示(例外: 公司"作恶" - 百度的"竞价排名")
     * 身份证书: 通过第三方CA作证, 证明网站不会被冒充
     
  3. HTTPS如何解决上面的风险?
     * **混合加密** - 非对称 + 对称
       * 通信建立前采用非对称加密的方式交换
       * 原因
         * 对称加密只有一个密钥, 运算速度快, 但相对不安全(服务器端和客户端共用一把钥匙用来进行数据的加密和解密, 数据传输时也要传输密钥, 容易被窃听)
         * 非对称加密使用两个密钥: 公钥和私钥, 公钥可以任意分发而私钥保密, 解决了密钥交换问题但速度慢.(公钥加密信息, 私钥解密信息, 传输的是公钥加密的信息, 同时带有CA的数字签名 + 公钥)
     * **摘要算法** - 为数据生成独一无二的校验码, 用于检测数据的完整性, 防止被篡改
       * 通过将校验码和明文共同加密后, 发送给另一端, 解密后需要用相同的摘要算法算出发送过来的明文, 对比计算出的明文和发送过来的明文是否一致, 验证数据完整性 
   * 将服务器公钥放入**数字证书**中, 防止冒充
       * 由第三方权威机构颁发的数字证书, 证明公钥是否可信
  
  4. HTTPS如何建立连接, 期间交互了什么
  
     1. 首先, 客户端向服务器发起加密请求, 称为**ClientHello**, 包括
  
         * 客户端支持的SSL/TLS协议版本
         * 加密组件(使用的加密算法、密钥长度)
  2. 服务器端收到客户端的请求后, 向客户端发出响应, 称为**ServerHello**.
        * 确认SSL/TLS版本
        * 加密组件(从客户端发送的内容中筛选出来的)
     3. 客户端回应: 客户端收到服务器的回应之后, 通过浏览器、操作系统中的CA公钥, 确认服务器数字证书的真实性
        * 随机数, 用于公钥加密
     4. 服务器最后回应: 服务器端根据随机数, 计算出**会话密钥**, 发送最后的信息.
     5. SSL/TLS握手阶段结束, 客户端与服务器端建立加密通信, 使用HTTP协议.
  
* 参考

  * https://leetcode-cn.com/circle/discuss/cxn9hV/

### 3. TCP与UDP在网络协议中的哪一层, 它们之间有什么区别?

* 在网络协议中属于**传输层**

1. 连接
   * TCP是面向连接的传输层协议, 传输前要先建立连接
   * UDP不需要连接, 即刻传输数据
2. 服务对象
   * TCP是一对一的两点服务, 即一条连接只有两个端点
   * UDP支持一对一、一对多、多对多的交互通信
3. 可靠性
   * TCP是可靠交付数据的, 数据可以无差错、不丢失、不重复、按需到达
   * UDP是尽最大努力交付, 不保证可靠交付数据
4. 拥塞控制、流量控制
   * TCP由拥塞控制和流量控制机制, 保证数据传输的安全性
   * UDP没有, 即使网络拥堵, 也不会影响UDP发送速率
5. 传输方式
   * TCP是流式传输, 没有边界, 保证顺序和可靠
   * UDP是一个包一个包的发送, 有边界, 但可能会丢包和乱序

* 扩展

  1. 二者的应用场景
       1. TCP面向连接, 保证数据可靠性交付
  
           * FTP文件传输
           * HTTP/HTTPS
      2. 由于UDP面向无连接, 它可以随时发送数据, 再加上UDP本身的处理简单高效, 所以应用于
         * 包总量较少的通信, DNS
         * 视频、音频
         * 广播通信
      
  2. TCP如何保证可靠传输?
     
     1. 在传输时, 应用程序会被分割成TCP认为最适合发送的数据块
     
     2. TCP给发送的每一个包进行编号, 接收方对数据包进行排序, 把有序数据传送给应用层
     
     3. TCP接收端会丢弃重复的数据
     
     4. 校验和:
        * TCP保持一个端对端的校验和, 目的是监测数据在传输过程中是否发生变化, 如果收到的校验和有差错, TCP将丢弃这个报文段
     5. 流量控制
        * TCP连接的每一方都有固定大小的缓冲空间, TCP的接收端只允许发送端发送接收缓冲区能接纳的数据
     6. 拥塞控制
        * 当网络阻塞时, 减少数据发送
     7. ARQ协议:
        * 每发完一个分组就停止发送, 等待对方确认, 在收到确认后再发下一个分组.
     8. 超时重传
        * 当TCP发出一个段后, 它启动一个定时器, 等待目的端确认收到这个报文段, 如果不能即使受到一个确认, 将重发这个报文段



### 4. TCP三次握手和四次挥手的流程, 为什么需要三次握手以及四次挥手?

* 思路: 叙述三次握手的流程, 解释如果不是三次会有什么影响

```
# TCP连接的四次交互
1 A --(A的SYN报文)------------> B  第一次交互
2 A <-(ACK - 确认A的SYN)------- B  第二次交互
3 A <----------(B的SYN报文)---- B  第三次交互
4 A --(ACK - 确认B的SYN)------> B  第四次交互

# 其中, 报文2、3可以合并起来, 作为一次握手
# 所以, 三次握手分别为 1,23,4

# 关闭连接
1 A --(FIN)-------------------> B  第一次交互
2 A <-(ACK - 确认A的FIN请求)---- B  第二次交互
3 A <----------(FIN)----------- B  第三次交互
4 A --(ACK - 确认B的FIN请求)---> B  第四次交互

# 在这个过程中, 报文2、3不能合并
# 收到FIN请求时, 可能还有数据没有发完, 先回复ACK, 表示收到断开连接的亲求. 等到数据发完后再发FIN, 断开服务器到客户端的数据发送.
```



* 扩展

  1. TCP建立连接可以两次握手吗? 为什么?

     * 不可以

     * 两次握手无法保证Client正确接收第二次握手的报文(Server无法确认Client是否收到), 也无法保证Client和Server之间成功交换初始序列表.
       * 如果是两次握手的话, 就缺少了4的步骤, 这样就导致A收到B的信息可靠, 而B收到A的信息不可靠. 

  2. 为什么连接的时候是三次握手，关闭的时候却是四次握手？

     * 三次握手: 当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

     * 四次挥手: 关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

* 参考

  * https://www.zhihu.com/question/24853633
  * https://www.cnblogs.com/bj-mr-li/p/11106390.html
  * https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ

  * https://github.com/WeiS49/Waking-Up/blob/master/Computer%20Network.md#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-three-way-handshake

### 5. 从输入URL到展现页面的全过程

1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

* 参考
  * https://github.com/WeiS49/Waking-Up/blob/master/Computer%20Network.md#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B-%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD



## 数据库

### 6. 简述什么是最左匹配原则, 为什么是这个原则?

* 根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
* 在构建联合索引的同时, 就隐含了(a, b, c)的重要性排序(按从左到右的顺序), 遍历的时候也应如此.
* 索引的底层是一颗B+树, 因此联合索引也是一颗B+树
  * 而联合索引的键值数量是多个
  * B+树只能根据一个值来构建
  * B+树是一个有序树
* 因此, 数据库依据联合索引最左的字段来构建B+树

```
# 举例:
# 创建一个(a, b, c)联合索引
# 在这个索引中, a起决定性因素
# 数据库首先会对第一个字段a进行排序, 然后才是b, c
# 因此, 在搜索语句中, 应该优先查找a, 然后是b, 最后才是c
# 假设a、b确定, 则查找到的c是按顺序排列
# 若只有b、c确定, 此时a无法确定, 结果没有连续性
# 补充: 在select语句中, a、b、c的顺序可以不固定, 因为可以借助查询优化器explan来纠正sql语句的顺序, 
```



### 7. 简述乐观锁以及悲观锁的区别以及使用场景

* 锁机制本身就是为了解决程序运行中产生的**并发问题**, 而乐观锁和悲观锁分别对应了两种策略

* 乐观锁

  * 每次事务需要读取对象时, 记录下当前的'版本号、时间戳等(称为x)'(应该就像git的commit), 只判断当前写入事务的x是否与读取时一致(比如github这种就提供在线记录x的功能), 如果一致则允许吸入, 否则拒绝.
  * 优点:
    * 因此, 这种锁更加适合高并发的多读少写的系统, (不要求持续占用单一线程, 但响应速度快) 适用于事务冲突少的场景.
  * 缺点:
    * 无法保证某两次数据写入操作之间是否发生了修改, ABA问题
  * 使用场景:
    * 版本控制系统: git、SVN

* 悲观锁

  * 当事务出现时, 悲观锁启动直到事务完成, 之后再处理下一个事务

  * 优点:

    * 保证了数据库操作的准确性

  * 缺点也很明显:

    1. 对于数据库的设计能力以及数据库功能间的独立性要求较高, 否则就会发生**死锁**
    2. 相当于'单线程'执行请求, 在高并发环境下会浪费大量资源

  * 使用场景:

    * 因为悲观锁一次只锁定一个事务, 所以变相缓解了并发, 但如果并发数据量极其庞大的时候, 这会造成资源的极大浪费, 所以适合并发量较小且用户能够接受高并发时运行效率低的项目.

    

### 8. MySQL为什么使用B+树来作为索引, 对比B树它的优点和缺点是什么

* 为什么用B+树
  * 为什么不用B树
    * mysql将数据保存在磁盘中, 读取数据会产生磁盘IO消耗
    * B树的非叶子节点会保存数据, 而B+树非叶子节点不保存数据
      * 因此B+树的每个节点可以存放更多key, 而同等效果下, B树的高度会比B+树更高, 从而产生更多的磁盘IO消耗
    * B+树叶子节点构成链表, 更有利于范围查找和排序. 而B树进行范围查找和排序需要对树进行递归遍历.
  * 为什么不用红黑树(自平衡二叉搜索树)
    * 红黑树会使树的高度更高, 增加IO消耗
  * 为什么不是用哈希表
    * 哈希表对于范围查找和排序效率低, 但对于单个数据的查询效率高

* 优缺点
  1. B+树层级更少, 查找更快
  2. B+树查询速度稳定: 由于B+树所有数据都存储在叶子节点, 所以查询任意数据的次数都是树的高度h
  3. B+树全节点遍历更快: 所有叶子节点构成链表, 全节点扫描只需遍历这个链表
  4. B树优点：如果在B树中查找的数据离根节点近，由于B树节点中保存有数据，那么这时查询速度比B+树快。(因为B树使用递归, 如果离根节点近, 只需要很少的递归. 而B+树相对就比较慢, 但胜在稳定.)

* 参考
  * https://blog.csdn.net/water12233/article/details/113832828



### 9. 什么情况下会发生死锁, 如何解决死锁?

* 情况
  * **互斥**：一个资源一次只能被一个进程使用；
  * **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
  * **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
  * **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。

* 解决

  * 死锁忽略

    * 直接忽略死锁, 因为解决死锁问题的代价很高, 所以遇到这种情况就不采取任何措施, 交由用户自行处理, 比如重启系统. 适用于死锁发生概率低, 或者死锁不会造成太大影响的情况. 

  * 死锁预防

    * 破坏互斥条件: 允许某些资源同时被多个进程访问, 但是有些资源本身不具有这种属性, 因此这种方案实用性有限
    * 破坏占有并等待条件: 
      * 预先分配资源(当一个进程开始运行之前, 必须一次性向系统申请他所需要的全部资源, 否则不运行)
      * 或者只允许进程在没有占用资源的时候才能申请资源(申请资源前显示放占有的资源)
      * 缺点: 很多时候无法预知一个进程所需的所有资源; 同时, 会降低资源利用率, 降低系统的并发性.
    * 破坏非抢占条件: 允许进程强行抢占被其他进程占有的资源, 会降低系统性能
    * 破坏循环等待条件: 对所有资源统一编号, 所有进程对资源的请求必须按照序号递增的顺序提出, 只有占有了编号较小的资源才能申请编号较大的资源. 这样避免了占有大号资源的进城去申请小号资源.

  * 死锁避免

    * 进程每次申请资源的时候, 就根据一定算法, 去看该请求可不可能造成死锁, 如果可能, 就不给它分配资源.

  * 死锁处理

    1. 挂起某进程, 抢占它的资源, 但应防止该进程被长时间挂起而产生不良影响

    2. 将进程回滚到足以解除死锁的程度, 要求保持进程的历史信息, 设置还原点

    3. 杀死进程: 强制杀死进程直到死锁接触, 可以按照优先级进行.

* 参考
  * https://blog.csdn.net/weixin_43748615/article/details/105498167
  * https://github.com/WeiS49/Waking-Up/blob/master/Operating%20Systems.md#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81



## 操作系统

### 10. 进程和线程之间有什么区别?

* 区别

	1. 进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；
	2. 线程依赖于进程而存在，一个进程至少有一个线程；
	3. 进程有自己的独立地址空间，线程共享所属进程的地址空间；
	4. 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
	5. 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
	6. 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；

* 扩展
  
  1. 同一进程中的线程可以共享哪些数据?
  
     * 内存, 其中包括
       * 进程的公有数据(全局变量、静态变量)
       * 进程的当前目录
  
  2. 线程独占资源
     * 线程ID
      * 线程自身的栈(堆是共享的)
  
     

* 参考
  
  * https://github.com/WeiS49/Waking-Up/blob/master/Operating%20Systems.md#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB

## 系统设计

### 11. 如何设计秒杀系统?








