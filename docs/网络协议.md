# 网络协议



## 索引

* [网络连接](#网络连接)
	* [Cookie和Session的关系和区别是什么](#Cookie 和 Session 的关系和区别是什么)



[toc]







## 网络连接



### TCP滑动窗口

* 流量控制是为了控制发送方发送速率，保证接收方来得及接收。

* 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
* 若网络正常, 则调大窗口, 增加接受的数据量, 否则减小





### 简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT

* TIME_WAIT

  * 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

  * 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

  * 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。





### Cookie 和 Session 的关系和区别是什么

* Cookie
  * Cookie是一种由访问的服务器发送到用户浏览器并保存在本地的数据, 当浏览器下次向服务器发起请求时发送到目标服务器上, 用于告知请求是否来自同一浏览器, 帮助基于无状态的HTTP协议记录稳定的状态信息.
    * 主要应用于
      1. 用户登录状态管理
      2. 自定义的个性化设置
      3. 浏览器行为跟踪和分析
* Session
  * Session就是服务器和用户端一次会话的过程. Session对象存储当前用户会话需要的属性及配置信息. 当用户在应用程序的Web页面中跳转的时候, 存储在Session对象中的变量将不会丢失, 从而确保用户会话一种存在下去, 当客户端关闭, Session超时失效, 会话结束.

* 联系
  * 当用户第一次请求某个服务器时, 服务器会根据该用户提交的信息创建相应的Session ID, 并将Session ID存储于Cookie中, Cookie同时记录Session ID所从属的域名
  * 当用户第二次请求该服务器时, 会自动判断当前域名下是否存在Cookie信息, 如果存在则发送Cookie信息到服务器端, 服务器端从Cookie中获取Session ID, 并根据Session ID查找对应的Session信息, 没找到则说明用户未登录或登录失效, 如果找到说明用户可以进行之后的操作
  * 综上所述, Cookie与Session通过Session ID进行连接, 共同用于判断当前用户登陆状态.

* 区别
  * 作用范围不同, Cookie保存在客户端(浏览器), Session保存在服务器端
  * 存取方式不同, Cookie只能保存ASCII, Session可以存任意数据类型
  * 有效期不同, Cookie可以长时间保持(默认登陆功能), Session失效时间短, 当客户端关闭、Session超时会引起失效
  * 隐私策略不同, 由于Cookie存储在客户端, 比较容易被窃取, Session存储于服务器端, 安全性相对较好.
  * 存储大小不同, 单个Cookie存储数据不能超过4K, Session可存储数据远高于Cookie



* 参考资料

  * [了解cookie和session](https://www.cnblogs.com/ityouknow/p/10856177.html)





### 什么是跨域，什么情况下会发生跨域请求？



* 概念

  * 浏览器从一个域名的网页去请求另一个域名的资源时, 受同源策略的限制, 若非同源, 被称为跨域
  * 出于安全性考虑, 浏览器限制脚本内发起跨域HTTP请求

* 同源

  * 域名、协议、端口均相同

* 案例

  ```
  http://www.123.com/index.html 调用 http://www.123.com/server.PHP （非跨域）
  
  http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）
  
  http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）
  
  http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）
  
  http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）
  
  请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。
  ```


* 实例

  在运行本地脚本时, 如果不使用本地服务器, 可能会触发跨域(CORS), 导致脚本无法正常运行




* 参考资料

  * [CSDN](https://blog.csdn.net/weixin_43207025/article/details/110352823)

  * [什么是跨域](https://segmentfault.com/a/1190000015597029)

  * [MDN Web Docs - 跨域资源分享](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)

  * [MDN Web Docs - 浏览器的同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)

  * [浅谈CSRF攻击方式](https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html)

  * [什么是跨域请求以及实现跨域的方案](https://www.jianshu.com/p/f880878c1398)





## HTTP



### GET与POST的区别？

1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；
2. GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；
3. 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；
4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；
6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制



### HTTP是什么?

* What: 

  * HTTP是一种协议, 全称是 [超文本传输协议]
* Why

  * 就像租房要签合同, 公司有公司规定一样. 计算机之间的交流通信也需要一种规范
* 它应用于计算机网络中, 应用计算机能够理解的语言确立了一种计算机之间通信的规范, 以及相关的各种控制和错误处理方式.
* How
* 既然是计算机之间, 那就说明这是一个双向协议
	  * 比如说网上购物, 我下单之后商家把物品寄给我, 我也可以因为不满意而把物品退给商家, 而这个过程都是在相应的平台监管之下的, 平台的管理条例就相当于是一种协议.
    * 而在实际的上网环境下, 用户就是请求方, 而目标网站就是应答方. 双方约定采用HTTP协议来通信, 于是浏览器就把请求信息发送给网站(我想要找存储在你服务器上的xxx内容), 网站对请求信息进行解析后, 将一些数据(其中包括状态码、请求的内容或者错误消息等)返回给浏览器
      * 比如说: 如果找到, 返回状态码200, 浏览器根据收到的数据将其渲染在屏幕上, 用户就能看到图片、视频了
      * 若没有找到: 可能返回状态码404, 表示这个内容没有找到, 返回错误信息.
* 引申
  * HTTP状态码
  * 输入URL到展现页面的全过程

### HTTP 请求方法



* HTTP协议定义了一组请求方法, 表明对给定资源执行的操作. 每一个请求方法具有不同的语义



* GET
  * 发送请求来获得服务器上的资源, 请求体中不会包含请求数据, 请求数据放在协议头中, 支持快取、缓存
  * 语法: GET /index.html
* HEAD
  * 同GET类似, 但是响应中没有呈现数据, 而是http的头信息, 主要用来检查资源或超链接的有效性或是否可以可达、网页是否被篡改或更新, 获取头信息, 适合速度有限的带宽
  * 语法: HEAD /index.html
* POST
  * 向服务器提交资源让服务器处理, 如提交表单、上传文件, 可能导致建立新的资源或对原有资源的修改. 提交的资源放在请求体中. 不支持快取
  * 语法: POST /test 
* PUT
  * 同POST类似, 但发送资源的时候, 要求客户端事先指定在服务器中的位置, 因此put相对较安全, 不会出现多次创建资源的情况
  * 语法: PUT /new.html HTTP/1.1
* DELETE
  * 请求服务器删除某资源. 
  * 语法: DELETE /file.html HTTP/1.1
* CONNECT
  * HTTP/1.1协议中预留的能够将连接更改为管道方式的代理服务器. 就是把服务器作为跳板, 去访问其他网页, 然后把数据返回回来, 连接成功后, 就可以正常get、post了.
  * 语法: CONNECT www.example.com: 443 HTTP/1.1
* OPTIONS
  * 获取http服务器支持的http请求方法, 允许客户端查看服务器性能, 笔记ajax跨域时的预检等.
  * 语法: OPTIONS /index.html HTTP/1.1 | OPTIONS * HTTP/1.1
* TRACE
  * 回显服务器收到的请求, 主要用于测试或诊断. 一般禁用, 防止被恶意攻击或盗取信息
  * 语法: TRACE /index.html



* 参考资料

  * [HTTP协议的六种请求方法](https://www.cnblogs.com/phpper/p/9127553.html)

  * [HTTP请求方法|MDN Web Docs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)





### HTTP 与 HTTPS 有哪些区别？

* 从安全性考虑, HTTP采用明文传输, 数据未加密, 安全性较差. HTTPS数据在传输过程是加密的, 安全性较好
* 响应速度不同, HTTP页面响应速度一般比HTTPS更快, 因为HTTP使用TCP三次握手建立连接, 客户端和服务器需要交换3个包, 而HTTPS除此之外还有ssl握手需要的9个包, 共12个包
* 占用端口不同, HTTP采用80端口, HTTPS采用443端口
* 耗费资源不同, HTTPS是建构在SSL/TLS上的HTTP协议, 相当于加了一个中间层, 所以HTTPS要比HTTP耗费更多服务器资源



* 参考资料

  * [HTTP与HTTPS的区别](https://www.runoob.com/w3cnote/http-vs-https.html)

  * [What is the difference between HTTP and HTTPS?](https://www.keycdn.com/blog/difference-between-http-and-https)





### HTTP1.0、HTTP1.1 和 HTTP2.0 的区别



* HTTP1.0和HTTP1.1的一些区别
  1. 带宽优化及网络连接的使用
     * HTTP1.0中, 存在浪费带宽的现象, 如果用户请求部分信息, 服务器却需要发送整个对象, 且不支持断点续传. HTTP1.1在请求头中引入了range头域, 允许值请求资源的某个部分, 返回码是206(Partial Content), 方便了开发者自由的选的以便于充分利用带宽和连接
  2. 错误通知
     * HTTP1.1新增了24个错误状态响应码, 相比之下能够更精准的判断错误信息
  3. Host头处理
     * HTTP1.1的请求消息和响应消息都支持Host头域, 且请求消息中如果没有Host头域会报错(400 Bad Request)
  4. 长连接
     * HTTP1.1支持长连接和请求的流水线处理, 在一个TCP连接上可以传送多个HTTP请求和响应, 减少了建立和关闭连接的延迟.



* HTTP2.0相比HTTP1.x的新特性
  1. 新的二进制格式
     * HTTP1.x的解析是基于文本, 由于文本协议的格式解析相对复杂, 所以较难实现健壮性, HTTP2.0协议决定采用二进制格式, 方便且健壮
  2. 多路复用
     * 连接共享, 每一个request都被用作连接共享机制. 一个request对应一个id, 这样一个连接上可以有多个request, 每个连接的request可以随机的混杂在一起, 接收方可以根据request的id将request再归属到各自不同的服务端请求里面, 节约了系统资源.
  3. header压缩
     * HTTP1.x的header带有大量信息, 且每次都要重复发送, HTTP2.0使用encoder来减少需要传输的header大小, 通讯双方各持有一份header fields表, 既避免了重复header的传输, 又减少了需要传输的大小
  4. 服务端推送
     * 提供server push功能



* 参考资料

  * [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://www.jianshu.com/p/be29d679cbff)





### 简述常见的HTTP状态码的含义(301, 304, 401, 403)

* 首先应该记住状态码从1xx - 5xx这几个大类代表的含义

  * 1xx 服务器已经收到请求, 但需要请求者进行操作(登陆中的验证操作?)
  * 2xx 说明请求成功
  * 3xx 说明访问被重定向到了其他网站, 相当于做了一个中转(DNS污染?)
  * 4xx 当前请求语法错误或无法完成请求(比如著名的404 NOT FOUND), 是客户端的问题
  * 5xx, 是服务器端出现问题, 无法完成请求(崩溃、宕机、不支持功能、无效响应)

* 301 当前资源被永久的改变了位置, 但会包含重定向的地址

* 304 客户端请求的内容和之前相比没有改变, 此时不需要重新传输资源

* 401 当前资源需要身份验证(当前资源需要登陆才能访问、登录信息过期, 需要重新验证)

* 403 服务器成功解析请求, 但请求被拒绝(同401不同的是, 403与身份验证无关)

  



* 参考资料

  * [Wiki](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)

  * [RUNOOB](https://www.runoob.com/http/http-status-codes.html)

  * [MDN Web Docs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)





## TCP



### TCP怎么保证可靠传输?

* TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

1. 在传输时, 应用程序会被分割成TCP认为最适合发送的数据块
2. TCP给发送的每一个包进行编号, 接收方对数据包进行排序, 把有序数据传送给应用层
3. TCP接收端会丢弃重复的数据
4. 校验和: 
   * TCP将保持一个端对端的检验和, 目的是在监测数据在传输过程中的任何变化. 如果收到的检验和有差错, TCP将丢弃这个报文段和不确认收到此报文段
5. 流量控制: 
   * TCP连接的每一方都有固定大小的缓冲空间, TCP的接收端只允许发送端发送接收缓冲区能接纳的数据.
6. 拥塞控制: 
   * 当网络拥塞时, 减少数据发送
7. ARQ协议: 
   * 每发完一个分组就停止发送, 等待对方确认.在收到确认后再发下一个分组
8. 超时重传: 
   * 当TCP发出一个段后, 它启动一个定时器, 等待目的端确认收到这个报文段, 如果不能及时收到一个确认, 将重发这个报文段



* 参考资料

  * [JavaGuide](https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%e5%9b%9b-tcp-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93)



### TCP粘包、拆包及解决办法



* 什么是TCP粘包
  * 假设客户端向服务器端连续发送了两个数据包, 分别为p1和p2, 但接收端只收到了一个数据包, 由于TCP不会出现丢包, 所以这个数据包中包含了发送端发送的两个数据包的信息, 这种现象叫做粘包. 由于接收端不知道两个数据包的界限, 所以对于接收端来说很难处理.
* 什么是TCP拆包
  * 同以上情况, 但这时接收端收到了两个数举报, 但这两个数据包要么不完整, 要么多出来一块, 这种情况就是发生了拆包和粘包. 同样对于接收端不好处理
* 解决办法
  1. 发送端给每个数据包添加包首部, 首部中应该至少包含数据包的长度, 这样在接收端收到数据后, 通过读取包首部的长度字段, 便知道每一个数据包的实际长度了.
  2. 发送端将每个数据包封装为固定长度(不够的通过0填充), 这样接收端每次从缓冲区中读取固定长度的数据就自然而然地把每个数据包拆分开来
  3. 可以在数据包之间设置边界, 如添加特殊符号, 这样, 接收端通过这个边界就可以将不同的数据包拆分开



* 参考资料

	* [博客园 - TCP粘包、拆包及解决办法](https://www.cnblogs.com/panchanggui/p/9518735.html)









## 加密



### 简述对称与非对称加密的概念



* A和B之间的通信内容需要加密, 如果A/B使用相同的密钥进行加密解密, 这就叫对称加密
  * 这种加密方式要求加密/解密的密钥唯一, 如果为了安全考虑, 对于每一个通信方都需要一组密钥,  这样的话, 如果链接增多, 需要管理大量的key, 需要庞大的维护成本, 而且影响大量信息交流的效率
  * 就像现实中每一把锁对应一把钥匙, 开锁和上锁都要用到它. 如果需要开的锁增加, 钥匙的数量也随之增加, 大量的钥匙增加了维护成本
* 与对称加密只用一把密钥进行加密解密不同, 非对称加密需要两个密钥: 公开密钥和私有密钥, 公开密钥和私有密钥是一对, 如果使用公开密钥加密, 只能用私有密钥才能解密, 反之同理. 加密和解密用的是不同的密钥, 这种算法叫非对称加密
  * 在这个过程中, 公开密钥可以随意传输, 只要私有密钥不泄露, 信息的安全就得到了保障.
  * 常见的例子有github的ssh key, 银行的U盾等



* 参考资料

  * [对称加密和非对称加密](https://www.cnblogs.com/lakei/p/11165987.html)



